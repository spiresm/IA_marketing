<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Galerie de Prompts - Espace IA</title>
    <link rel="stylesheet" href="style.css" />
    <style>
        /* Styles pour les transitions de visibilité du body et main */
        body {
            opacity: 0;
            transition: opacity 0.5s ease-in; /* 'ease-in' pour une apparition douce */
        }

        body.show {
            opacity: 1;
        }

        main {
            opacity: 0; /* Gardez ceci pour la transition d'apparition de main */
            transition: opacity 0.5s ease-in; /* 'ease-in' pour une apparition douce */
            padding: 40px 20px; /* Appliqué ici, car il est spécifique à main */
        }

        main.show {
            opacity: 1;
        }

        /* Styles spécifiques à la galerie */
        .gallery-container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .gallery-header {
            text-align: center;
            color: #0077b6;
            margin-bottom: 30px;
        }

        .filter-controls {
            display: flex;
            flex-wrap: wrap; /* Permet aux éléments de passer à la ligne */
            gap: 15px;
            margin-bottom: 30px;
            justify-content: center; /* Centre les filtres */
            align-items: flex-end; /* Aligne les éléments du bas */
        }

        .filter-group {
            flex: 1; /* Permet aux groupes de filtres de prendre de la place */
            min-width: 200px; /* Largeur minimale pour éviter le rétrécissement excessif */
        }

        .filter-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: #333;
        }

        .filter-group input[type="text"],
        .filter-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
            background: #f9fafb;
            box-sizing: border-box; /* Important pour que padding n'augmente pas la largeur */
        }

        .gallery-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
            gap: 25px;
            padding: 20px 0;
        }

        .prompt-card {
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.08);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            height: 100%; /* Assure que toutes les cartes ont la même hauteur */
        }

        .prompt-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.12);
        }

        .prompt-card img {
            width: 100%;
            height: 200px; /* Hauteur fixe pour les images */
            object-fit: cover; /* Recadre l'image pour couvrir la zone */
            display: block;
            border-bottom: 1px solid #eee;
        }

        .prompt-card-content {
            padding: 20px;
            display: flex;
            flex-direction: column;
            flex-grow: 1; /* Permet au contenu de prendre l'espace restant */
        }

        .prompt-card-content h3 {
            color: #0077b6;
            margin-top: 0;
            margin-bottom: 10px;
            font-size: 1.25em;
        }

        .prompt-card-content p {
            font-size: 0.95em;
            color: #555;
            line-height: 1.5;
            margin-bottom: 15px;
            flex-grow: 1; /* Permet au paragraphe de prendre plus de place */
            white-space: pre-wrap; /* Préserve les retours à la ligne */
            word-wrap: break-word; /* Casse les mots longs */
        }

        .prompt-meta {
            font-size: 0.85em;
            color: #888;
            border-top: 1px dashed #eee;
            padding-top: 10px;
            margin-top: 10px;
        }

        .prompt-meta span {
            display: block;
            margin-bottom: 3px;
        }

        .no-results {
            text-align: center;
            color: #777;
            font-size: 1.2em;
            padding: 50px 0;
        }

        .loader {
            display: block;
            margin: 50px auto;
            width: 50px;
            height: 50px;
            border: 5px solid #f3f3f3;
            border-top: 5px solid #0077b6;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Message de succès après redirection */
        .success-message {
            background-color: #d4edda;
            color: #155724;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 8px;
            text-align: center;
            font-weight: bold;
            border: 1px solid #badbcc;
            opacity: 0; /* Commence invisible */
            animation: fadeIn 0.5s forwards; /* Animation d'apparition */
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>

    <div id="header-placeholder"></div>
    <main>
        <div id="app"></div>
    </main>

    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>

    <script>
        const apiBase = window.location.origin + '/.netlify/functions/';

        document.addEventListener("DOMContentLoaded", () => {
            console.log("DOMContentLoaded déclenché pour galerie.html");

            const headerPlaceholder = document.getElementById("header-placeholder");
            const mainElement = document.querySelector("main");
            const bodyElement = document.body;

            // Déstructure les fonctions de Vue 3 (ref, createApp, computed, onMounted)
            const { ref, createApp, computed, onMounted, nextTick } = Vue;

            // Simple fonction de debounce pour limiter les appels de filtre
            function debounce(fn, delay) {
                let timeoutId = null;
                return function(...args) {
                    clearTimeout(timeoutId);
                    timeoutId = setTimeout(() => fn.apply(this, args), delay);
                };
            }

            // Définition du composant Vue
            const GalleryApp = {
                template: `
                    <div class="gallery-container">
                        <h2 class="gallery-header">Galerie des Prompts IA</h2>

                        <div v-if="successMessage" class="success-message">
                            {{ successMessage }}
                        </div>

                        <div class="filter-controls">
                            <div class="filter-group">
                                <label for="search">Rechercher un mot-clé :</label>
                                <input type="text" id="search" v-model="searchTerm" @input="debouncedFilter" placeholder="Filtrer par texte, outil, chaîne..." />
                            </div>

                            <div class="filter-group">
                                <label for="authorFilter">Filtrer par auteur :</label>
                                <select id="authorFilter" v-model="selectedAuthor" @change="applyFilters">
                                    <option value="">Tous les auteurs</option>
                                    <option v-for="authorName in uniqueAuthors" :key="authorName" :value="authorName">{{ authorName }}</option>
                                </select>
                            </div>
                        </div>

                        <div v-if="isLoading" class="loader"></div>
                        <div v-else-if="filteredPrompts.length === 0" class="no-results">
                            Aucun prompt trouvé pour les critères de recherche.
                        </div>
                        <div v-else class="gallery-grid">
                            <div class="prompt-card" v-for="prompt in filteredPrompts" :key="prompt._id">
                                <img v-if="prompt.imageUrl" :src="prompt.imageUrl" :alt="'Image pour le prompt: ' + prompt.texte" />
                                <img v-else src="https://via.placeholder.com/280x200?text=Pas+d%27image" alt="Pas d'image disponible" />
                                <div class="prompt-card-content">
                                    <h3>{{ prompt.outil }} ({{ prompt.chaine }})</h3>
                                    <p>{{ prompt.texte }}</p>
                                    <div class="prompt-meta">
                                        <span>Par: {{ prompt.auteur || 'Anonyme' }}</span>
                                        <span>Publié le: {{ formatDate(prompt.date) }}</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                `,
                setup() {
                    const prompts = ref([]);
                    const isLoading = ref(true);
                    const searchTerm = ref(''); // Nouveau: pour la recherche par mot-clé
                    const selectedAuthor = ref(''); // Pour le filtre par auteur
                    const successMessage = ref('');

                    // Débounce la fonction de filtrage pour le champ de recherche
                    const debouncedFilter = debounce(() => {
                        // Pas besoin de faire grand-chose ici, computed property fera le travail
                        console.log('Filtre de recherche déclenché après debounce');
                    }, 300); // Délai de 300ms

                    // Gère l'application des filtres (principalement pour le select, le input est debounced)
                    function applyFilters() {
                        // Le computed property filteredPrompts se mettra à jour automatiquement
                        console.log('Filtres appliqués');
                    }

                    // Calculer les auteurs uniques à partir de tous les prompts chargés
                    const uniqueAuthors = computed(() => {
                        const authors = new Set();
                        prompts.value.forEach(p => {
                            if (p.auteur && p.auteur.trim() !== '') {
                                authors.add(p.auteur.trim());
                            }
                        });
                        // Convertir en tableau et trier alphabétiquement
                        return Array.from(authors).sort((a, b) => a.localeCompare(b));
                    });

                    // Filtrer les prompts en fonction des critères
                    const filteredPrompts = computed(() => {
                        let filtered = prompts.value;

                        // 1. Filtre par mot-clé (searchTerm)
                        if (searchTerm.value) {
                            const lowerCaseSearchTerm = searchTerm.value.toLowerCase();
                            filtered = filtered.filter(prompt =>
                                prompt.texte.toLowerCase().includes(lowerCaseSearchTerm) ||
                                prompt.outil.toLowerCase().includes(lowerCaseSearchTerm) ||
                                prompt.chaine.toLowerCase().includes(lowerCaseSearchTerm)
                            );
                        }

                        // 2. Filtre par auteur sélectionné
                        if (selectedAuthor.value) {
                            filtered = filtered.filter(prompt =>
                                (prompt.auteur || 'Anonyme').toLowerCase() === selectedAuthor.value.toLowerCase()
                            );
                        }

                        return filtered;
                    });

                    // Fonction pour charger les prompts depuis Netlify Function
                    async function fetchPrompts() {
                        isLoading.value = true;
                        try {
                            const response = await fetch(`${apiBase}getGalleryPrompts`);
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            const data = await response.json();
                            prompts.value = data; // Assurez-vous que data est un tableau de prompts
                        } catch (error) {
                            console.error("Erreur lors du chargement des prompts:", error);
                            // Gérer l'affichage d'une erreur à l'utilisateur si nécessaire
                        } finally {
                            isLoading.value = false;
                        }
                    }

                    // Fonction pour formater la date
                    function formatDate(dateString) {
                        const options = { year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit' };
                        return new Date(dateString).toLocaleDateString('fr-FR', options);
                    }

                    // Exécuter la fonction de chargement au montage du composant
                    onMounted(() => {
                        fetchPrompts();
                        // Vérifier le message de succès dans l'URL
                        const urlParams = new URLSearchParams(window.location.search);
                        if (urlParams.get('success') === '1') {
                            successMessage.value = 'Votre prompt a été partagé avec succès !';
                            // Supprimer le paramètre d'URL après affichage
                            history.replaceState({}, document.title, window.location.pathname);
                            // Faire disparaître le message après quelques secondes
                            setTimeout(() => {
                                successMessage.value = '';
                            }, 5000);
                        }
                    });

                    return {
                        prompts,
                        isLoading,
                        searchTerm,
                        selectedAuthor,
                        uniqueAuthors,
                        filteredPrompts,
                        successMessage,
                        debouncedFilter, // Exposer la fonction debounced
                        applyFilters,
                        formatDate,
                    };
                }
            };

            // Chargez le header d'abord
            fetch("header.html")
                .then(res => {
                    console.log("Header fetch response:", res.status);
                    if (!res.ok) {
                        return Promise.reject(res);
                    }
                    return res.text();
                })
                .then(data => {
                    headerPlaceholder.innerHTML = data;
                    console.log("Header chargé dans le placeholder.");
                    // Activez le lien de navigation correspondant
                    document.querySelectorAll("nav a").forEach(link => {
                        if (link.getAttribute("href") === "galerie.html") {
                            link.classList.add("active");
                            console.log("Lien 'Galerie' activé.");
                        }
                    });
                })
                .catch(error => {
                    console.error("Erreur de chargement du menu (header.html):", error);
                    headerPlaceholder.innerHTML = "<p style='color:red;text-align:center'>Erreur de chargement du menu</p>";
                })
                .finally(() => {
                    // Montez l'application Vue.js SEULEMENT après le chargement du header
                    createApp(GalleryApp).mount('#app');
                    console.log("Application Vue montée sur #app.");

                    // Rendre le body et le main visibles après le chargement du header ET le montage de Vue
                    nextTick(() => {
                        bodyElement.classList.add("show");
                        mainElement.classList.add("show");
                        console.log("Classes 'show' ajoutées à body et main après le montage de Vue.");
                    });
                });
        });
    </script>
</body>
</html>
