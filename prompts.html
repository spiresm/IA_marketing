<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Partager un Prompt - Espace IA</title>
    <link rel="stylesheet" href="style.css" />
    <style>
        /* Styles pour les transitions de visibilité du body et main */
        body {
            opacity: 0;
            transition: opacity 0.5s ease-in;
        }

        body.show {
            opacity: 1;
        }

        main {
            opacity: 0;
            transition: opacity 0.5s ease-in;
            padding: 40px 20px;
        }

        main.show {
            opacity: 1;
        }

        /* Vos autres styles CSS spécifiques à cette page (déplacés dans .container pour clarté) */
        .container {
            max-width: 600px;
            margin: 0 auto;
            background: #fff;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.05);
            padding: 30px;
            position: relative;
        }

        .retour-lien {
            display: inline-block;
            margin-bottom: 20px;
            color: #0077b6;
            text-decoration: none;
            font-weight: bold;
            font-size: 1.05em;
        }

        .retour-lien:hover {
            text-decoration: underline;
        }

        label {
            font-weight: 600;
            display: block;
            margin-top: 15px;
            margin-bottom: 5px;
        }

        input, select, textarea {
            width: 100%;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 1em;
            background: #f9fafb;
            box-sizing: border-box;
        }
        
        /* Styles spécifiques pour le groupe Auteur */
        .form-group-auteur {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .form-group-auteur button {
            width: auto;
            padding: 8px 15px;
            margin-top: 5px;
            align-self: flex-start;
        }

        #drop-zone {
            border: 2px dashed #0077b6;
            padding: 20px;
            text-align: center;
            color: #777;
            margin-top: 10px;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.2s;
        }

        #drop-zone.dragover {
            background: #e0f7ff;
        }

        #image-preview {
            display: block;
            max-width: 80%;
            height: auto;
            margin: 15px auto;
            border-radius: 10px;
            border: 1px solid #eee;
        }

        button {
            width: 100%;
            padding: 12px;
            background: #0077b6;
            color: #fff;
            border: none;
            border-radius: 8px;
            margin-top: 25px;
            font-size: 1em;
            cursor: pointer;
            box-sizing: border-box;
            transition: background 0.2s;
        }

        button:hover {
            background: #005f8a;
        }

        .confirmation {
            margin-top: 30px;
            padding: 20px;
            background: #e6ffed;
            border: 1px solid #b7eb8f;
            border-radius: 10px;
            text-align: center;
            color: #28a745;
            font-weight: bold;
        }

        .confirmation img {
            max-width: 80%;
            height: auto;
            margin-top: 15px;
            border-radius: 10px;
            border: 1px solid #b7eb8f;
        }

        .loader {
            display: block;
            margin: 20px auto;
            width: 40px;
            height: 40px;
            border: 4px solid #ccc;
            border-top: 4px solid #0077b6;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .form-message {
            margin-top: 15px;
            padding: 10px;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
        }

        .form-message.success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #badbcc;
        }

        .form-message.error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
    </style>
</head>
<body>

    <div id="header-placeholder"></div>
    <main>
        <div id="app"></div>
    </main>

    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>

    <script>
        const apiBase = window.location.origin + '/.netlify/functions/';

        document.addEventListener("DOMContentLoaded", () => {
            console.log("DOMContentLoaded déclenché pour prompts.html");

            const headerPlaceholder = document.getElementById("header-placeholder");
            const mainElement = document.querySelector("main");
            const bodyElement = document.body;

            const { ref, createApp, nextTick, onMounted } = Vue;

            const PromptForm = {
                template: `
                    <div class="container">
                        <a href="galerie.html" class="retour-lien">← Retour à la galerie</a>
                        <h2 style="text-align:center; color:#0077b6;">Partager un prompt</h2>
                        <form @submit.prevent="submitForm">
                            <div class="form-group-auteur">
                                <label for="auteurSelect">Auteur du prompt :</label>
                                <select id="auteurSelect" v-model="auteur" :disabled="isCreatingNewAuthor" required>
                                    <option value="">Sélectionner un auteur existant</option>
                                    <option v-for="auth in auteurs" :key="auth.name" :value="auth.name">{{ auth.name }}</option>
                                </select>
                                <button type="button" @click="toggleNewAuthorInput" :class="{'btn-secondary': isCreatingNewAuthor}">
                                    {{ isCreatingNewAuthor ? 'Annuler la création d\'auteur' : 'Créer un nouvel auteur' }}
                                </button>
                                <input type="text"
                                        id="newAuthorNameInput"
                                        v-if="isCreatingNewAuthor"
                                        v-model="newAuthorName"
                                        placeholder="Nom du nouvel auteur"
                                        required
                                        @input="clearAuthorSelect" />
                            </div>
                            <label for="outil">Outil IA utilisé</label>
                            <select id="outil" v-model="outil" required>
                                <option value="">-- Sélectionnez un outil --</option>
                                <option>Midjourney</option>
                                <option>DALL·E</option>
                                <option>Stable Diffusion</option>
                                <option>Adobe Firefly</option>
                                <option>Runway</option>
                                <option>ChatGPT</option>
                                <option>Autre</option>
                            </select>

                            <label for="chaine">Chaîne / Média d'origine</label>
                            <select id="chaine" v-model="chaine" required>
                                <option value="">-- Sélectionnez une chaîne --</option>
                                <option>La Une</option>
                                <option>Tipik</option>
                                <option>La Trois</option>
                                <option>La Première</option>
                                <option>Classic 21</option>
                                <option>Vivacité</option>
                                <option>Musiq3</option>
                                <option>Auvio</option>
                                <option>Autre</option>
                            </select>

                            <label for="texte">Texte du prompt</label>
                            <textarea id="texte" v-model="texte" rows="6" required placeholder="Ex: Un paysage futuriste avec des néons et des éléments de la nature, style art nouveau"></textarea>

                            <label>Image (facultatif)</label>
                            <div id="drop-zone"
                                    @click="triggerFile"
                                    @dragover.prevent="onDragOver"
                                    @dragleave="onDragLeave"
                                    @drop.prevent="onDrop">
                                <p>Déposez une image ici ou cliquez pour la sélectionner.</p>
                                <p v-if="selectedFileName">Fichier sélectionné : {{ selectedFileName }}</p>
                            </div>
                            <input type="file" ref="fileInput" accept="image/*" style="display:none" @change="onFileChange" />
                            <img v-if="imagePreviewUrl" :src="imagePreviewUrl" id="image-preview" alt="Aperçu de l'image" />
                            <p v-if="imagePreviewUrl" style="text-align: center; margin-top: 5px;">
                                <button type="button" @click="clearImage" style="width: auto; padding: 5px 10px; margin-top: 0; background: #dc3545;">Supprimer l'image</button>
                            </p>


                            <div v-if="formMessage" :class="['form-message', messageType]">{{ formMessage }}</div>
                            <div v-if="isLoading" class="loader"></div>
                            <button v-else type="submit" :disabled="isLoading">Partager le prompt</button>
                        </form>

                        <div class="confirmation" v-if="confirmationVisible">
                            <p>✅ Prompt partagé avec succès vers la <strong>galerie</strong> !</p>
                            <img v-if="confirmationImageUrl" :src="confirmationImageUrl" alt="Image du prompt partagé" />
                            <p style="white-space: pre-wrap;">{{ confirmationTexte }}</p>
                            <p style="margin-top: 15px; color: #0077b6;">Redirection vers la galerie dans {{ countdown }} secondes...</p>
                        </div>
                    </div>
                `,
                setup() {
                    const auteur = ref(''); // Valeur sélectionnée dans le dropdown des auteurs
                    const auteurs = ref([]); // Liste des auteurs à afficher dans le dropdown
                    const isCreatingNewAuthor = ref(false); // Indique si l'utilisateur est en train de créer un nouvel auteur
                    const newAuthorName = ref(''); // Nom du nouvel auteur à saisir

                    const outil = ref('');
                    const chaine = ref('');
                    const texte = ref('');
                    const fileInput = ref(null);
                    const imagePreviewUrl = ref('');
                    const selectedFileName = ref('');
                    const confirmationVisible = ref(false);
                    const confirmationImageUrl = ref('');
                    const confirmationTexte = ref('');
                    const isLoading = ref(false);
                    const formMessage = ref('');
                    const messageType = ref('');
                    const countdown = ref(3);

                    // Charger les auteurs au montage du composant Vue
                    onMounted(() => {
                        fetchAuthors();
                    });

                    async function fetchAuthors() {
                        try {
                            // Appel à une fonction Netlify qui va récupérer TOUS les prompts
                            // et en extraire les auteurs uniques pour le select.
                            // C'est une approche si vous n'avez pas de collection d'auteurs séparée.
                            const response = await fetch(`${apiBase}getGalleryPrompts`);
                            if (!response.ok) {
                                throw new Error(`HTTP error! status: ${response.status}`);
                            }
                            const allPrompts = await response.json();
                            
                            const uniqueAuthors = new Set();
                            allPrompts.forEach(prompt => {
                                if (prompt.auteur && prompt.auteur.trim() !== '') {
                                    uniqueAuthors.add(prompt.auteur.trim());
                                }
                            });
                            
                            // Convertir le Set en tableau, le trier et mettre à jour le ref `auteurs`
                            // Chaque auteur est un objet { name: "Nom" } pour la compatibilité avec v-for
                            auteurs.value = Array.from(uniqueAuthors)
                                .sort((a, b) => a.localeCompare(b))
                                .map(name => ({ name: name }));
                            
                            console.log("Auteurs chargés pour le formulaire:", auteurs.value);

                        } catch (error) {
                            console.error("Erreur lors du chargement des auteurs pour le formulaire:", error);
                            formMessage.value = "Impossible de charger la liste des auteurs. Veuillez réessayer plus tard.";
                            messageType.value = "error";
                        }
                    }

                    function toggleNewAuthorInput() {
                        isCreatingNewAuthor.value = !isCreatingNewAuthor.value;
                        if (isCreatingNewAuthor.value) {
                            auteur.value = ''; // Désélectionne l'auteur existant quand on veut en créer un nouveau
                            nextTick(() => {
                                document.getElementById('newAuthorNameInput')?.focus();
                            });
                        } else {
                            newAuthorName.value = ''; // Réinitialise le champ du nouvel auteur si on annule
                        }
                    }

                    function clearAuthorSelect() {
                        // Lorsque l'utilisateur commence à taper dans le champ "nouvelAuteurInput",
                        // on désélectionne automatiquement l'option du select existant.
                        auteur.value = '';
                    }

                    function triggerFile() { fileInput.value?.click(); }
                    function onDragOver(e) { e.currentTarget.classList.add('dragover'); }
                    function onDragLeave(e) { e.currentTarget.classList.remove('dragover'); }
                    function onDrop(e) {
                        e.currentTarget.classList.remove('dragover');
                        const files = e.dataTransfer.files;
                        if (files.length) {
                            fileInput.value.files = files;
                            handleFile(files[0]);
                        }
                    }
                    function onFileChange(e) {
                        const file = e.target.files[0];
                        if (file) handleFile(file);
                    }
                    function handleFile(file) {
                        if (!file.type.startsWith('image/')) {
                            formMessage.value = 'Veuillez sélectionner un fichier image valide.';
                            messageType.value = 'error';
                            clearImage();
                            return;
                        }
                        selectedFileName.value = file.name;
                        const reader = new FileReader();
                        reader.onload = () => { imagePreviewUrl.value = reader.result; };
                        reader.readAsDataURL(file);
                        formMessage.value = '';
                    }
                    function clearImage() {
                        imagePreviewUrl.value = '';
                        selectedFileName.value = '';
                        if (fileInput.value) fileInput.value.value = null;
                    }

                    function getBase64(file) {
                        return new Promise((resolve, reject) => {
                            const reader = new FileReader();
                            reader.onload = () => resolve(reader.result.split(',')[1]);
                            reader.onerror = error => reject(error);
                            reader.readAsDataURL(file);
                        });
                    }

                    async function submitForm() {
                        formMessage.value = '';
                        messageType.value = '';
                        confirmationVisible.value = false;
                        isLoading.value = true;

                        let finalAuteur = '';
                        if (isCreatingNewAuthor.value) {
                            finalAuteur = newAuthorName.value.trim();
                        } else {
                            finalAuteur = auteur.value.trim();
                        }

                        // Validation côté client pour l'auteur
                        if (!finalAuteur) {
                            formMessage.value = 'Veuillez sélectionner ou entrer un nom d\'auteur.';
                            messageType.value = 'error';
                            isLoading.value = false;
                            return;
                        }
                        
                        // Validation pour les autres champs obligatoires
                        if (!outil.value || !chaine.value || !texte.value.trim()) {
                            formMessage.value = 'Veuillez remplir tous les champs obligatoires (Outil, Chaîne, Prompt).';
                            messageType.value = 'error';
                            isLoading.value = false;
                            return;
                        }

                        let finalImageUrl = '';
                        const file = fileInput.value?.files?.[0];

                        try {
                            if (file) {
                                const base64 = await getBase64(file);
                                const payload = { fileBase64: base64, fileName: file.name };
                                console.log("Envoi de l'image à Netlify Function...");
                                const resp = await fetch(`${apiBase}uploadImage`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify(payload)
                                });
                                if (!resp.ok) {
                                    const errorData = await resp.json();
                                    throw new Error(`Échec de l'upload de l'image: ${resp.status} - ${errorData.message || 'Erreur inconnue'}`);
                                }
                                const data = await resp.json();
                                finalImageUrl = data.url;
                                console.log("Image uploadée, URL:", finalImageUrl);
                            }

                            console.log("Envoi du prompt à Netlify Function...");
                            const promptResp = await fetch(`${apiBase}pushPrompt`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({
                                    auteur: finalAuteur,
                                    outil: outil.value,
                                    chaine: chaine.value,
                                    texte: texte.value,
                                    imageUrl: finalImageUrl,
                                    date: new Date().toISOString()
                                })
                            });

                            if (!promptResp.ok) {
                                const errorData = await promptResp.json();
                                throw new Error(`Échec de l'archivage du prompt: ${promptResp.status} - ${errorData.message || 'Erreur inconnue'}`);
                            }

                            console.log("Prompt archivé avec succès.");
                            confirmationImageUrl.value = finalImageUrl;
                            confirmationTexte.value = texte.value;
                            confirmationVisible.value = true;
                            formMessage.value = 'Prompt partagé avec succès !';
                            messageType.value = 'success';

                            let count = 3;
                            countdown.value = count;
                            const interval = setInterval(() => {
                                count--;
                                countdown.value = count;
                                if (count <= 0) {
                                    clearInterval(interval);
                                    window.location.href = "/galerie.html?success=1";
                                }
                            }, 1000);

                            // Réinitialiser le formulaire
                            auteur.value = '';
                            newAuthorName.value = '';
                            isCreatingNewAuthor.value = false;
                            outil.value = '';
                            chaine.value = '';
                            texte.value = '';
                            clearImage();
                            fetchAuthors(); // Recharger la liste des auteurs pour inclure le nouvel auteur si créé
                        } catch (err) {
                            console.error("Erreur lors de l'envoi du formulaire:", err);
                            formMessage.value = `Échec du partage: ${err.message || 'Vérifiez la console.'}`;
                            messageType.value = 'error';
                        } finally {
                            isLoading.value = false;
                        }
                    }

                    return {
                        auteur, auteurs, isCreatingNewAuthor, newAuthorName, toggleNewAuthorInput, clearAuthorSelect,
                        outil, chaine, texte, fileInput,
                        imagePreviewUrl, selectedFileName,
                        confirmationVisible, confirmationImageUrl, confirmationTexte,
                        isLoading, formMessage, messageType, countdown,
                        triggerFile, onDragOver, onDragLeave, onDrop, onFileChange,
                        handleFile, clearImage, submitForm
                    };
                }
            };

            // Chargez le header d'abord
            fetch("header.html")
                .then(res => {
                    console.log("Header fetch response:", res.status);
                    if (!res.ok) {
                        return Promise.reject(res);
                    }
                    return res.text();
                })
                .then(data => {
                    headerPlaceholder.innerHTML = data;
                    console.log("Header chargé dans le placeholder.");
                    document.querySelectorAll("nav a").forEach(link => {
                        if (link.getAttribute("href") === "prompts.html") {
                            link.classList.add("active");
                            console.log("Lien 'Archiver un prompt' activé.");
                        }
                    });
                    // Montez l'application Vue seulement après que le header est chargé avec succès
                    createApp(PromptForm).mount('#app');
                    console.log("Application Vue montée sur #app.");

                    nextTick(() => {
                        bodyElement.classList.add("show");
                        mainElement.classList.add("show");
                        console.log("Classes 'show' ajoutées à body et main après le montage de Vue.");
                    });
                })
                .catch(error => {
                    console.error("Erreur de chargement du menu (header.html):", error);
                    headerPlaceholder.innerHTML = "<p style='color:red;text-align:center'>Erreur de chargement du menu</p>";
                    // Si le header ne charge pas, on n'ajoute pas les classes 'show' au body/main via nextTick ici
                    // car cela pourrait être le signe que la page est destinée à rester vide ou à afficher un message d'erreur.
                    // Cependant, pour s'assurer que le formulaire Vue est tenté de s'afficher, on peut le monter ici aussi,
                    // mais il faut faire attention à ne pas le monter deux fois.
                    // La meilleure pratique est de le monter UNE SEULE fois à la fin d'un chemin réussi.
                    // Pour ce cas, laissons le FINALLY gérer le montage.
                })
                .finally(() => {
                    // Monte l'application Vue SI elle n'a pas déjà été montée (par exemple, en cas d'erreur de chargement du header)
                    // Cette vérification est importante pour éviter les doubles montages.
                    if (!document.querySelector('#app')._vue_app) { 
                         createApp(PromptForm).mount('#app');
                         console.log("Application Vue montée sur #app dans le bloc finally.");

                         nextTick(() => {
                             bodyElement.classList.add("show");
                             mainElement.classList.add("show");
                             console.log("Classes 'show' ajoutées à body et main après le montage de Vue dans finally.");
                         });
                    }
                });
        });
    </script>
</body>
</html>
